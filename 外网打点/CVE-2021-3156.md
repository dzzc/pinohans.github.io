## 1. 基本信息

CVE-2021-3156：sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具。此漏洞主要是由于sudoedit和sudo对命令行参数解析处理不一致导致的。

影响范围：1.8.2 <= Sudo <= 1.8.31p2, 1.9.0 <= Sudo <= 1.9.5p1

- Qualys Research Team发现此漏洞的[文章地址](https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit)
- 部分可用crash的具体细节[文章地址](https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt)

## 2. 分析

### 2.1. 漏洞成因

1. sudo在执行shell命令模式（-s或-i）下，会把所有的命令拼接在一起。

``` c++
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
        char **av, *cmnd = NULL;
        int ac = 1;
        ...
            cmnd = dst = reallocarray(NULL, cmnd_size, 2);
            ...
            for (av = argv; *av != NULL; av++) {
                for (src = *av; *src != '\0'; src++) {
                    /* quote potential meta characters */
                    if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
                        *dst++ = '\\'; // 转译
                    *dst++ = *src;
                }
                *dst++ = ' '; // 空格拼接
            }
            ...
            ac += 2; /* -c cmnd */
            ...
        av = reallocarray(NULL, ac + 1, sizeof(char *));
        ...
        av[0] = (char *)user_details.shell; /* plugin may override shell */
        if (cmnd != NULL) {
            av[1] = "-c";
            av[2] = cmnd;
        }
        av[ac] = NULL;

        argv = av;
        argc = ac;
    }
```

2. 后续会把参数再反转译回来，但此处判断不严谨，如果`\`是最后一个字符，配合`\x00`绕过isspace判断，使得此处继续反转译后续字符串，造成user_args指向的堆内存堆溢出。

``` c++
    if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
        ...
            for (size = 0, av = NewArgv + 1; *av; av++)
                size += strlen(*av) + 1;
            if (size == 0 || (user_args = malloc(size)) == NULL) {
                ...
            }
            if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
            ...
                for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                    while (*from) {
                        if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                            from++; // 反转译
                        *to++ = *from++;
                    }
                    *to++ = ' ';
                }
                ...
            }
            ...
    }
```

3. 因此寻找满足以下逻辑，且不进入sudo主程序中转译部分的输入，即只要满足`MODE_SHELL & (MODE_EDIT | MODE_CHECK)`，就可以触发漏洞。

```
sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)
ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)
```

理论上，`sudo -s -e/-l`结合可以达到目标

但是：

- 存在`MODE_RUN`会进入转译阶段
- `sudo`的`-e/-l`模式会重置`valid_flags`，造成验证不通过。

``` c++
                case 'e':
                    ...
                    mode = MODE_EDIT;
                    sudo_settings[ARG_SUDOEDIT].value = "true";
                    valid_flags = MODE_NONINTERACTIVE;
                    break;
                    ...
                case 'l':
                    ...
                    mode = MODE_LIST;
                    valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;
                    break;
                    ...
    if (argc > 0 && mode == MODE_LIST)
        mode = MODE_CHECK;
        ...
    if ((flags & valid_flags) != flags)
        usage(1);
```

后来发现`sudoedit`的默认模式不存在`MODE_RUN`，且使用`-s`模式不会重置`valid_flags`，因此可以利用。

···
#define DEFAULT_VALID_FLAGS  (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)
    ...
    int valid_flags = DEFAULT_VALID_FLAGS;
    ...
    proglen = strlen(progname);
    if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0) {
        progname = "sudoedit";
        mode = MODE_EDIT;
        sudo_settings[ARG_SUDOEDIT].value = "true";
    }
···

### 2.2. PoC

由于堆溢出覆盖了top chunk的头部，因此报错。

``` bash
$ sudoedit -s '\' `perl -e 'print "A" x 65536'`
malloc(): corrupted top size
Aborted
```

### exp思路


该团队在[文章](https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt)中给出部分可用crash的具体细节，网上大部分利用思路围绕在第2点，即service_user结构体的overwrite。

在glibc中service_user结构体定义如下

``` c++
typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;
```

具体产生利用位置如下，堆溢出至`ni`指向地址，使得`ni->library == NULL`避免crash，此时进入`nss_new_service`函数，从而进入`ni->library->lib_handle == NULL`逻辑。溢出同时改掉`name`的内容，

``` c++
static int
nss_load_library (service_user *ni)
{
  if (ni->library == NULL)
    {
    ...
      ni->library = nss_new_service (service_table ?: &default_table,
                                     ni->name);
    ...
    }

  if (ni->library->lib_handle == NULL)
    {
      /* Load the shared library.  */
      size_t shlen = (7 + strlen (ni->name) + 3
                      + strlen (__nss_shlib_revision) + 1);
      int saved_errno = errno;
      char shlib_name[shlen];

      /* Construct shared object name.  */
      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
                                              "libnss_"),
                                    ni->name),
                          ".so"),
                __nss_shlib_revision);

      ni->library->lib_handle = __libc_dlopen (shlib_name);
```


### 2.3. 修复

更新sudo版本

## 3. 复现

[https://github.com/pinohans/vulbox/tree/master/CVE-2021-3156](https://github.com/pinohans/vulbox/tree/master/CVE-2021-3156)
