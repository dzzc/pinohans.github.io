## 1. 基本信息

CVE-2016-4437(SHIRO-550)：Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。

## 2. 分析

### 2.1. 漏洞成因

```java
// org/apache/shiro/mgt/AbstractRememberMeManager.java
public abstract class AbstractRememberMeManager implements RememberMeManager {
    ...
    private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode("kPH+bIxk5D2deZiIxcaaaA==");
    ...
    public AbstractRememberMeManager() {
        this.serializer = new DefaultSerializer<PrincipalCollection>();
        this.cipherService = new AesCipherService();
        setCipherKey(DEFAULT_CIPHER_KEY_BYTES); // 使用硬编码密钥
    }
    ...
}
```

### 2.2. 触发过程

1. shiro-web: OncePerRequestFilter#doFilter，处理HTTP请求
2. shiro-core: DefaultSecurityManager#getRememberedIdentity, 获得cookie中rememberMe部分
3. shiro-core: AbstractRememberMeManager#convertBytesToPrincipals, 解密
4. shiro-core: DefaultSerializer#deserialize, 反序列化触发

### 2.3. 调用栈

```
deserialize:68, DefaultSerializer (org.apache.shiro.io)
deserialize:514, AbstractRememberMeManager (org.apache.shiro.mgt)
convertBytesToPrincipals:431, AbstractRememberMeManager (org.apache.shiro.mgt)
getRememberedPrincipals:396, AbstractRememberMeManager (org.apache.shiro.mgt)
getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)
resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt)
createSubject:342, DefaultSecurityManager (org.apache.shiro.mgt)
buildSubject:846, Subject$Builder (org.apache.shiro.subject)
buildWebSubject:148, WebSubject$Builder (org.apache.shiro.web.subject)
createSubject:292, AbstractShiroFilter (org.apache.shiro.web.servlet)
doFilterInternal:359, AbstractShiroFilter (org.apache.shiro.web.servlet)
doFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)
```

### 2.4. 修复

shiro-root-1.2.4与1.2.5的[对比](https://github.com/apache/shiro/compare/shiro-root-1.2.4...shiro-root-1.2.5#diff-2e7d73672987b1848c5e21ba5c3e5ed1eebe8a827b7a8f6d9bec6cb358a9cfc6)

```java
// org/apache/shiro/mgt/AbstractRememberMeManager.java
public abstract class AbstractRememberMeManager implements RememberMeManager {
    
    ...

    public AbstractRememberMeManager() {
        this.serializer = new DefaultSerializer<PrincipalCollection>();
        AesCipherService cipherService = new AesCipherService();
        this.cipherService = cipherService;
        setCipherKey(cipherService.generateNewKey().getEncoded());
    }

    ...

}
```

## 3. 复现

### ysoserial CommonCollections2

[漏洞环境源码]

### 3.1. tips

1. 在java 1.6版本之后，默认`sun.lang.ClassLoader.allowArraySyntax=false`，所以网上文章说编译需要指定1.6版本，但是使用高版本也可以验证漏洞，不过运行时需要增加参数`-Dsun.lang.ClassLoader.allowArraySyntax=true`。
2. shiro-root-1.2.4自身不能使用ysoserial的利用链，所以触发漏洞需要增加目标版本的依赖。
3. 由于shiro重写了resolveClass方法，将原生方法中的forName方法替换为loadClass方法，由于loadClass无法加载数组类型的类，因此存在Transformer[]类的CommonCollections gadget无法成功利用此漏洞，如CommonCollections1，CommonCollections3。
4. 复现时使用embedded jetty，使用maven shade插件打包成fat jar，但是发现jetty的WebAppContext.setWar不能直接使用jar包里的war包，因此在运行jar时把war包解压到本地再加载。
5. 用mvn package命令时，maven jar插件会自动执行一次id为default-jar的操作，优先级极高，但我们需要在此之前需要复制war包，因此需要屏蔽这个命令使用`<execution><id>default-jar</id><phase/></execution>`。
